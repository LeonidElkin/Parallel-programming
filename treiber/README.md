# Задача 1. Стек Трайбера

## Небольшое описание

Были реализованы два вида стека: elimination и Трайбера. Также были предоставлены тесты, чтобы убедиться в корректности работы стеков в параллельном режиме. 
Потокобезопасность была протестирована с помощью фреймворка `lincheck`

Elimination стек был реализован с помощью elimination массива. Его размер равен количеству потоков, однако используется не всегда весь.
Поддиапозон выбирается в соответствии с `RangePolicy`. 
Поддиапозон увеличивается в случае последовательных успешных взаимоуничтожений операций `push` и `pop` и уменьшается при последовательных неудачах. 

Ожидание второго потока для уничтожения составляет 10 микросекунд. Такое значение было выбрано экспериментальным путем, как наиболее оптимальное в большинстве случаев. 
Отмечу, что при увеличении этого времени на малом количетсве потоков, были получены лучшие результаты, а на большом - худшие, и наоборот. Такое происходит из-за 
того, что при большом количестве потоков гораздо больше шанс, что найдётся поток, который выполняет комплементарную массиву операцию, а потому и таймаут нужен меньший

## Тестирование производительности

Тестирование производительности призвано оценить какой прирост даёт алгоритм уничтожения в стеке

### Условия тестирования

Тесты производились на `Windows 11 23H2` на процессоре `11th Gen Intel(R) Core(TM) i7-11800H` 
(8 ядер с гипертрейдингом 16). Размеры кэшэй: `L1 - 640KB L2 - 10MB L3 - 24MB`

Код запускался на следующих входных данных: 1, 2, 4, 8, 16, 32, 50 потоков и 10 000, 100 000, 1 000 000 операций `push` и `pop` общее для весь потоков, а не для каждого. 
Количество операций `head` всегда было фиксировано и равнялось 1 000. Количество операций `head` не является существенным, 
так как она просто возвращает верхушку стека на данный момент времени и её не нужно синхронизировать между потоками

Каждый поток выполнял случайную из операций, которые ещё не были выполнены. При выполнении каждым потоком только одной операции(либо только `push`, либо только `pop`) были получены лучшие результаты, 
так как практически всегда находилась комплементарная операция в elimination массиве

Каждый тестируемый случай отрабатывался 500 раз и вычислялось среднее значение времени с целью уменьшения погрешности

### Результаты тестирования и анализ

#### Случайные операции

Результаты тестирования и сравнение можно посмотреть в [таблице](https://docs.google.com/spreadsheets/d/1JkDEy4ignt82WJ4Us4IJY3bLNKUBcTRxn45E8NKQGSo/edit?usp=sharing)

На одном потоке можно заметить небольшой упадок производительности, так как elimination стек содержит больше ветвлений и операций, 
да и в целом является более тяжеловесной структурой нежели стек Трайбера.

Однако, уже на двух потоках заметен прирост примерно в три раза на разном количестве тестовых данных. 
С увеличением потоков заметно небольшое увеличение коэффицента времени выполнения, это связано с большим шансом найти комплементарную операцию в массиве.

Также отмечу, что результаты очень колеблются от запуска к запуску, несмотря на то, что каждый тестовый случай измерялся 500 раз.
Это связано с неопределенной успешностью того или иного потока и варьирующимся шансом нахождения комплентарной операции

Подытожив, можно сказать, что elimination стек при случайном наборе операций, даёт прирост примерно в три раза, что можно было ожидать, с учетом того, что каждая операция выбирается с шансом примерно 33%.

#### Шахматный порядок

В данном тестовом случае потоки загружались операциями в шахматном порядке: половина из них начиналось с операции `pop`, половина с операции `push`, далее те, кто начинали с `pop` выполняли `push` и наоборот. И такое чередование продолжалось пока не кончатся все операции. Данный случай был призван участить количество успешных взаимоуничтожений комплементарных операций

Результаты можно посмотреть в [таблице](https://docs.google.com/spreadsheets/d/1gToBTay9wprmCC-W0AMxRY1Kk8uyuOyd1auImpjWfsw/edit?usp=sharing)

Как можно наблюдать, подготовленные данные дают существенный прирост относительно случайных данных. И при увеличении потоков и размера входных данных прирост увеличивается. Elimination стек отрабатывает в среднем в семь раз быстрее, чем стек Трайбера, иногда достигая прироста в 10 раз.

Такой прирост обусловлен тем, что elimination массив практически не простаивает, а политика выбора поддиапозона выбирает оптимальный размер массива и меняется в завимости от успешности операций взаимоуничтожения. В то время стек Трайбера из-за многопоточности наоборот вынужден простаивать очень долго, а большое количество потоков, которые хотят выполнить свои операции лишь усугубляет его положение

### Вывод

Elimination стек показывает ожидаемые прирост на случайных операциях и существенный прирост на подготовленных случаях. Стоит отметить, что результаты тестов могут меняться в зависимости от запуска к запуску из-за особенностей корутин, а также невозможности предсказать, сколько будут простаивать потоки в стеке Трайбера, однако результаты в таблицах показывают средние результаты на множестве запусков, что говорит о меньшей погрешности.
