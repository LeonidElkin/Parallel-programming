# Репозиторий

В качестве репозитория была выбрана реализация алгоритма Дейкстры для поиска кратчайших путей во взвешенном графе с помощью структуры
данных `Relaxed Multi-(Priority)-Queue`, написанная на `C++`. 
Также прилагаю [форк](https://github.com/LeonidElkin/parallel-programming-2-task), в котором производилась работа.

# Репозиторий до

В репозитории уже были написаны тесты, однако они проверяли работоспособность `*.h` файлов в целом, а не параллельные куски кода. Также стоит отметить, что в них было допущено много ошибок из-за чего изначально
они вообще не компилировались. Эти ошибки были мною исправлены, а тесты прошли, однако видно, что они писались на скорую рук, и не могут похвастаться большим покрытием.

В репозитории есть баш скрипт `download_datasets.sh`, который сам выкачивал и парсил данные с некого сайта, однако сайт, с которого брался архив с информацией, на данный момент не найден. Был найден снапшот сайта на Wayback 
machine и загружен в форк для удобства под именем

В `CMakeLists.txt` в флагах компилятора не было добавлено флага `-fsanitize=address -g`, однако видно, что автор при написании кода пользовался какими-то способами проверить корректность параллельныхь частей кода.
Далее проверки на корректность параллельных частей кода проводились с этим флагом.

---

Запуск производился со следующими параметрами `1 params.txt 5000 1 run`, где:
- `1` - это имя отредактированного датасета, удобного для парсинга, этот файл был загружен в форк под именем `1.in`
- `params.txt` - это текстовый файл, в котором было `6 4`, где `6` - это количество потоков, а `4` - это параметр, отвечающий за количество очередей в Multi-Queue(этот параметр умножался на количество потоков и получалось количество очередей)
- `5000` - это количество элементов в одной очереди
- `1` - это параметр, отвечающий за запуск параллельной версии, а не последовательной
- `run` - это запуск программы без бенчмарка

`ThreadSanitizer` выдал одно предупреждение о гонке данных, однако после тщательного изучение кода, оно было рассмотрено мной, как ложноположительное. Такое предположение было выдвинуто, потому что все 
операции, которые меняли состояние структуры данных, были обособлены операциями `lock` и `unlock`, то есть можно считать, что эти части кода выполнялись, как последовательные. Также в интернете были найдены
issue, с подобными ложноположительными срабатываниями санитайзера

## Репозиторий после

Гонка данных была внесена посредством удаления операций `lock` и `unlock` перед и после операции `pop` соответственно. `ThreadSanitizer` выдал свыше 60 предупреждений, которые все, за исключением одного, 
сигнализировали о гонке данных. Последнее предупреждение было SEGV, которые говорит о том, что мы пытаемся достучаться к ячейке памяти, к которой не должны, что как раз может являться следствием гонки данных.

<details>
  <summary> Ниже приложу скриншот с логами санитайзера в CLion(осторожно, белая тема) </summary>

  ![image](https://github.com/LeonidElkin/Parallel-programming/assets/113133848/700c093d-c3f1-4ad4-b77a-c7a05f7b7c5f)

</details>

Также прилагаю ссылку на логи работы программы, если кто-то хочет подробней ознакомиться с предупреждениями санитайзера. [Тык](log.txt)
